<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>HTML Ruby Markup Extensions</title>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async></script>
    <script class='remove'>
      var respecConfig = {
              specStatus:   "unofficial"
          ,   shortName:    "html-ruby-extensions"
          ,   editors:      [{ name: "Robin Berjon", url: "http://berjon.com/",
                               company: "W3C", companyURL: "http://w3.org/" }]
          ,   wg:           "HTML Working Group"
          ,   wgURI:        "http://www.w3.org/html/wg/"
          ,   wgPublicList: "public-html"
          ,   wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/40318/status"
          ,   edDraftURI:   "http://darobin.github.com/html-ruby/"
        };
    </script>
    <style>
      .element {
          background: none repeat scroll 0 0 #EEEEFF;
          border-left: 0.25em solid #9999FF;
          color: black;
          margin: 0 0 1em 0.15em;
          padding: 0 1em 0.25em 0.75em;
          position: relative;
          z-index: 1;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        The ruby markup model currently described in the HTML specification is limited in its
        support for a number of features, notably jukugo and double-sided ruby, as well as inline
        ruby. This specification addresses these issues by introducing new elements and changing
        the ruby processing model. Specific care has been taken to ensure that authoring remains
        as simple as possible.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This specification is a proposed extension specification to HTML and has no official
        standing whatsoever.
      </p>
    </section>
    <section>
      <h2>Changes compared to the current ruby model</h2>
      <p>
        The following changes are made to HTML by this document:
      </p>
      <ul>
        <li><code><a>ruby</a></code> nested inside <code><a>ruby</a></code> now represents its children;</li>
        <li>new <code><a>rb</a></code> and <code><a>rtc</a></code> elements have been introduced;</li>
        <li>
          the algorithm for processing ruby markup has been changed (note that if this
          extension is rejected, the original algorithm will still need to be modified because
          it is buggy);
        </li>
        <li>the HTML parsing algorithm has been changed to take the new elements into account.</li>
      </ul>
    </section>
    
    <!-- 
      TODO:
        - one section per element
          - ruby
          - rtc
        - parsing algorithm
        - any other mention of ruby (grep)
      
      CHANGE:
        - compound -> container
        - annotation -> ruby text
      
      UCs:
        - http://lists.w3.org/Archives/Public/www-style/2011Feb/0804.html
    -->

    <section>
      <h2>The <dfn><code>ruby</code></dfn> element</h2>
      <!-- XXX
        - take content model, basic prose, etc.
        - new examples
        - adapt prose to new model
        - describe usage of the composing elements
        - if inside <ruby>, represents its children
      -->
      <p>
        At any particular time, the segmentation and categorisation of content of a 
        <code><a>ruby</a></code> element is the result that would be obtained from 
        running the following algorithm:
      </p>
      <ol>
        <li>Let <var>root</var> be the <code><a>ruby</a></code> element for which the algorithm is being run.</li>
        <li>Let <var>index</var> be 0.</li>
        <!-- XXX the data model may be better explained above (also note they can be null) -->
        <li>
          Let <var>ruby segments</var> be an empty list. Each segment in this list is defined by
          a list of bases each of which is a DOM range, a base DOM range containing all bases for this
          segment, a first compound annotation, and a second compound annotation.
        </li>
        <li>Let <var>current bases</var> be an empty list of DOM ranges.</li>
        <li>Let <var>current bases range</var> be null.</li>
        <li>Let <var>current bases range start</var> be null.</li>
        <li>Let <var>current annotations</var> be an empty list of DOM ranges.</li>
        <li>Let <var>current annotations range</var> be null.</li>
        <li>Let <var>current annotations range start</var> be null.</li>
        <li>Let <var>current compound annotations</var> be an empty list.</li>
        <li>Let <var>current automatic base nodes</var> be an empty list of DOM Nodes.</li>
        <li>Let <var>current automatic base range start</var> be null.</li>
        <li>If <var>root</var> has a <code><a>ruby</a></code> element ancestor, then abort these steps.</li>
        <li>
          <i>Process a ruby child</i>: If <var>index</var> is equal to or greater than the number of
          child nodes in <var>root</var>, then run the steps to <a>commit a ruby segment</a>,
          return <var>ruby segments</var>, and abort these steps.
        </li>
        <li>
          Let <var>current child</var> be the <var>index</var>th node in <var>root</var>.
        </li>
        <li>
          If <var>current child</var> is not a <a>Text</a> node and is not an <a>Element</a>
          node, then increment <var>index</var> by one and jump to the step labelled <i>process a ruby child</i>.
        </li>
        <li>
          If <var>current child</var> is an <code><a>rp</a></code> element, then increment <var>index</var> by one and 
          jump to the step labelled <i>process a ruby child</i>.
        </li>
        <li>
          If <var>current child</var> is an <code><a>rt</a></code> element, then run these substeps:
          <ol>
            <li>Run the steps to <a>commit an automatic base</a>.</li>
            <li>Run the steps to <a>commit the base range</a>.</li>
            <li>
              If <var>current compound annotations</var> contains two elements, then run the steps to
              <a>commit a ruby segment</a>.
            </li>
            <li>
              If <var>current annotations</var> is empty, set <var>current annotations range start</var> to
              the value of <var>index</var>.
            </li>
            <li>
              Create a new DOM range whose <span title="concept-range-start">start</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var>) 
              and whose <span title="concept-range-end">end</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var> plus one), and
              append it at the end of <var>current annotations</var>.
            </li>
            <li>Increment <var>index</var> by one and jump to the step labelled <i>process a ruby child</i>.</li>
          </ol>
        </li>
        <li>
          If <var>current child</var> is an <code><a>rtc</a></code> element, then run these substeps:
          <ol>
            <li>Run the steps to <a>commit an automatic base</a>.</li>
            <li>Run the steps to <a>commit the base range</a>.</li>
            <li>Run the steps to <a>commit current annotations</a>.</li>
            <li>
              If <var>current compound annotations</var> contains two elements, then run the steps to
              <a>commit a ruby segment</a>.
            </li>
            <li>
              Create a new compound annotation. It is described by the list of annotations returned
              by running the steps to <a>process an <code>rtc</code> element</a> and a DOM
              range whose <span title="concept-range-start">start</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var>) 
              and whose <span title="concept-range-end">end</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var> plus one).
              Append this new compound annotations at the end of <var>current compound annotations</var>.
            </li>
            <li>
              If <var>current compound annotations</var> contains two elements, then run the steps to
              <a>commit a ruby segment</a>.
            </li>
            <li>Increment <var>index</var> by one and jump to the step labelled <i>process a ruby child</i>.</li>
          </ol>
        </li>
        <li>
          If <var>current child</var> is a <code>Text</code> node and is <a>inter-element whitespace</a>,
          then run these substeps:
          <ol>
            <li>
              If <var>current annotations</var> is not empty, increment <var>index</var> by one and jump to the 
              step labelled <i>process a ruby child</i>.
            </li>
            <li>
              If <var>current compound annotations</var> does not contain two elements, then run the following
              substeps:
              <ol>
                <li>Let <var>lookahead index</var> be set to the value of <var>index</var>.</li>
                <li><i>Peek ahead</i>: Increment <var>lookahead index</var> by one.</li>
                <li>
                  If <var>lookahead index</var> is equal to or greater than the number of
                  child nodes in <var>root</var>, then abort these substeps.
                </li>
                <li>
                  Let <var>peek child</var> be the <var>lookahead index</var>th node in <var>root</var>.
                </li>
                <li>
                  If <var>peek child</var> is a <code>Text</code> node and is <a>inter-element whitespace</a>,
                  then jump to the step labelled <i>peek ahead</i>.
                </li>
                <li>
                  If <var>peek child</var> is an <code><a>rt</a></code> element, an <code><a>rtc</a></code> element,
                  or an <code><a>rp</a></code> element, then set <var>index</var> to the value of <var>lookahead index</var>
                  and jump to the step labelled <i>process a ruby child</i>.
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          If <var>current annotations</var> is not empty or if <var>current compound annotations</var> is not
          empty, then run the steps to <a>commit a ruby segment</a>.
        </li>
        <li>
          If <var>current child</var> is an <code><a>rb</a></code> element, then run these substeps:
          <ol>
            <li>Run the steps to <a>commit an automatic base</a>.</li>
            <li>
              If <var>current bases</var> is empty, then set <var>current bases range start</var> to
              the value of <var>index</var>.
            </li>
            <li>
              Create a new DOM range whose <span title="concept-range-start">start</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var>) and whose 
              <span title="concept-range-end">end</a> is the <span title="concept-range-bp">boundary point</a> 
              (<var>root</var>, <var>index</var> plus one), and append it at the end of <var>current bases</var>.
            </li>
            <li>Increment <var>index</var> by one and jump to the step labelled <i>process a ruby child</i>.</li>
          </ol>
        </li>
        <li>
          If <var>current automatic base nodes</var> is empty, set <var>current automatic base range start</var>
          to the value of <var>index</var>.
        </li>
        <li>
          Append <var>current child</var> at the end of <var>current automatic base nodes</var>.
        </li>
        <li>Increment <var>index</var> by one and jump to the step labelled <i>process a ruby child</i>.</li>
      </ol>
      <p>
        When the steps above say to <dfn>commit a ruby segment</dfn>, it means to run the 
        following steps at that point in the algorithm:
      </p>
      <ol>
        <li>Run the steps to <a>commit an automatic base</a>.</li>
        <li>
          If <var>current bases</var>, <var>current annotations</var>, and <var>current compound annotations</var>
          are all empty, abort these steps.
        </li>
        <li>Run the steps to <a>commit the base range</a>.</li>
        <li>Run the steps to <a>commit current annotations</a>.</li>
        <li>
          Create a new ruby segment. It is described by a list of bases set to <var>current bases</var>,
          a base DOM range set to <var>current bases range</var>, and a first and second
          compound annotations that are respectively the first and second items of the
          <var>current compound annotations</var> list. Append this new ruby segment at the end of 
          <var>ruby segments</var>.
        </li>
        <li>Let <var>current bases</var> be an empty list.</li>
        <li>Let <var>current bases range</var> be null.</li>
        <li>Let <var>current bases range start</var> be null.</li>
        <li>Let <var>current compound annotations</var> be an empty list.</li>
      </ol>
      <p>
        When the steps above say to <dfn>commit the base range</dfn>, it means to run the 
        following steps at that point in the algorithm:
      </p>
      <ol>
        <li>If <var>current bases</var> is empty, abort these steps.</li>
        <li>If <var>current bases range</var> is not null, abort these steps.</li>
        <li>
          Let <var>current bases range</var> be a DOM range whose 
          <span title="concept-range-start">start</a> is the <span title="concept-range-bp">boundary
          point</a> (<var>root</var>, <var>current bases range start</var>) and whose 
          <span title="concept-range-end">end</a> is the <span title="concept-range-bp">boundary point</a>
          (<var>root</var>, <var>index</var>).
        </li>
      </ol>
      <p>
        When the steps above say to <dfn>commit current annotations</dfn>, it means to run the 
        following steps at that point in the algorithm:
      </p>
      <ol>
        <li>
          If <var>current annotations</var> is not empty and <var>current annotations range</var> is
          null let <var>current annotations range</var> be a DOM range whose 
          <span title="concept-range-start">start</a> is the <span title="concept-range-bp">boundary
          point</a> (<var>root</var>, <var>current annotations range start</var>) and whose 
          <span title="concept-range-end">end</a> is the <span title="concept-range-bp">boundary point</a>
          (<var>root</var>, <var>index</var>).
        </li>
        <li>
          If <var>current annotations</var> is not empty, create a new compound annotation. It is described
          by an annotations list set to <var>current annotations</var> and a range set to <var>current annotations range</var>.
          Append this new compound annotation at the end of <var>current compound annotations</var>.
        </li>
        <li>Let <var>current annotations</var> be an empty list of DOM ranges.</li>
        <li>Let <var>current annotations range</var> be null.</li>
        <li>Let <var>current annotations range start</var> be null.</li>
      </ol>
      <p>
        When the steps above say to <dfn>commit an automatic base</dfn>, it means to run the 
        following steps at that point in the algorithm:
      </p>
      <ol>
        <li>
          If <var>current automatic base nodes</var> is empty, abort these steps.
        </li>
        <li>
          If <var>current automatic base nodes</var> contains nodes that are not <code>Text</code>
          nodes, or <code>Text</code> nodes that are not <a>inter-element whitespace</a>, then
          run these substeps:
          <ol>
            <li>
              It <var>current bases</var> is empty, set <var>current bases range start</var> to the value of
              <var>current automatic base range start</var>.
            </li>
            <li>
              Create a new DOM range whose <span title="concept-range-start">start</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>current automatic base 
              range start</var>) and whose <span title="concept-range-end">end</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var>), and
              append it at the end of <var>current bases</var>.
            </li>
          </ol>
          <li>Let <var>current automatic base nodes</var> be an empty list of DOM Nodes.</li>
          <li>Let <var>current automatic base range start</var> be null.</li>
        </li>
      </ol>
    </section>
    
    <section>
      <h2>The <dfn><code>rb</code></dfn> element</h2>
      <dl class="element">
        <dt><span title="element-dfn-categories">Categories</span>:</dt>
        <dd>None.</dd>
        <dt><span title="element-dfn-contexts">Contexts in which this element can be used</span>:</dt>
        <dd>As a child of a <code>ruby</code> element.</dd>
        <dt><span title="element-dfn-content-model">Content model</span>:</dt>
        <dd><span>Phrasing content</span>.</dd>
        <dt><span title="element-dfn-attributes">Content attributes</span>:</dt>
        <dd><span>Global attributes</span></dd>
        <dt><span title="element-dfn-dom">DOM interface</span>:</dt><!--TOPIC:DOM APIs-->
        <dd>Uses <code>HTMLElement</code>.</dd>
      </dl><!--TOPIC:HTML-->

      <p>The <code>rb</code> element marks the base text component of a ruby annotation. When it is the
      child of a <code>ruby</code> element, it doesn't <span title="represents">represent</span> anything itself, 
      but its parent <code>ruby</code> element uses it as part of determining what <em>it</em>
      <span>represents</span>.</p>

      <div class="impl">
        <p>An <code>rb</code> element that is not a child of a <code>ruby</code> element
        <span>represents</span> the same thing as its children.</p>
      </div>
    </section>
    
    <section>
      <h2>The <dfn><code>rt</code></dfn> element</h2>
      <dl class="element">
        <dt><span title="element-dfn-categories">Categories</span>:</dt>
        <dd>None.</dd>
        <dt><span title="element-dfn-contexts">Contexts in which this element can be used</span>:</dt>
        <dd>As a child of a <code>ruby</code> or of an <code>rtc</code> element.</dd>
        <dt><span title="element-dfn-content-model">Content model</span>:</dt>
        <dd><span>Phrasing content</span>.</dd>
        <dt><span title="element-dfn-attributes">Content attributes</span>:</dt>
        <dd><span>Global attributes</span></dd>
        <dt><span title="element-dfn-dom">DOM interface</span>:</dt><!--TOPIC:DOM APIs-->
        <dd>Uses <code>HTMLElement</code>.</dd>
      </dl><!--TOPIC:HTML-->

      <p>The <code>rt</code> element marks the ruby text component of a ruby annotation. When it is the
      child of a <code>ruby</code> element or of an <code>rtc</code> element that is itself the child of
      a <code>ruby</code> element, it doesn't <span title="represents">represent</span> anything itself, 
      but its ancestor <code>ruby</code> element uses it as part of determining what <em>it</em>
      <span>represents</span>.</p>

      <div class="impl">
        <p>An <code>rt</code> element that is not a child of a <code>ruby</code> element
        or of an <code>rtc</code> element that is itself the child of a <code>ruby</code> element
        <span>represents</span> the same thing as its children.</p>
      </div>
    </section>
    
    <section>
      <h2>The <dfn><code>rtc</code></dfn> element</h2>
      <dl class="element">
        <dt><span title="element-dfn-categories">Categories</span>:</dt>
        <dd>None.</dd>
        <dt><span title="element-dfn-contexts">Contexts in which this element can be used</span>:</dt>
        <dd>As a child of a <code>ruby</code> element.</dd>
        <dt><span title="element-dfn-content-model">Content model</span>:</dt>
        <dd><span>Phrasing content</span>.</dd>
        <dt><span title="element-dfn-attributes">Content attributes</span>:</dt>
        <dd><span>Global attributes</span></dd>
        <dt><span title="element-dfn-dom">DOM interface</span>:</dt><!--TOPIC:DOM APIs-->
        <dd>Uses <code>HTMLElement</code>.</dd>
      </dl><!--TOPIC:HTML-->

      <p>The <code>rtc</code> element marks a ruby text container for ruby text components in a ruby annotation.
      When it is the child of a <code>ruby</code> element it doesn't <span title="represents">represent</span>
      anything itself, but its parent <code>ruby</code> element uses it as part of determining what <em>it</em>
      <span>represents</span>.</p>

      <div class="impl">
        <p>An <code>rtc</code> element that is not a child of a <code>ruby</code> element
        <span>represents</span> the same thing as its children.</p>
      </div>

      <p>
        When an <code><a>rtc</a></code> element is processed as part of the segmentation
        and categorisation of content for a <code><a>ruby</a></code> element, 
        the following algorithm defines how to <dfn>process an <code><a>rtc</a></code> element</dfn>:
      </p>
      <ol>
        <li>Let <var>root</var> be the <code><a>rtc</a></code> element for which the algorithm is being run.</li>
        <li>Let <var>index</var> be 0.</li>
        <li>Let <var>annotations</var> be an empty list of DOM ranges.</li>
        <li>Let <var>current automatic annotation nodes</var> be an empty list of DOM nodes.</li>
        <li>Let <var>current automatic annotation range start</var> be null.</li>
        <li>
          <i>Process an rtc child</i>: If <var>index</var> is equal to or greater than the number of
          child nodes in <var>root</var>, then run the steps to <a>commit an automatic annotation</a>,
          return <var>annotations</var>, and abort these steps.
        </li>
        <li>
          Let <var>current child</var> be the <var>index</var>th node in <var>root</var>.
        </li>
        <li>
          If <var>current child</var> is an <code><a>rt</a></code> element, then run these substeps:
          <ol>
            <li>Run the steps to <a>commit an automatic annotation</a>.</li>
            <li>
              Create a new DOM range whose <span title="concept-range-start">start</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var>) and 
              whose <span title="concept-range-end">end</a> is the 
              <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var> plus one), and
              append it at the end of <var>annotations</var>.
            </li>
            <li>Increment <var>index</var> by one and jump to the step labelled <i>process an rtc child</i>.</li>
          </ol>
        </li>
        <li>
          If <var>current automatic annotation nodes</var> is empty, set <var>current automatic annotation
          range start</var> to the value of <var>index</var>.
        </li>
        <li>
          Append <var>current child</var> at the end of <var>current automatic annotation nodes</var>.
        </li>
        <li>Increment <var>index</var> by one and jump to the step labelled <i>process an rtc child</i>.</li>
      </ol>
      <p>
        When the steps above say to <dfn>commit an automatic annotation</dfn>, it means to run the 
        following steps at that point in the algorithm:
      </p>
      <ol>
        <li>
          If <var>current automatic annotation nodes</var> is empty, abort these steps.
        </li>
        <li>
          If <var>current automatic annotation nodes</var> contains nodes that are not <code>Text</code>
          nodes, or <code>Text</code> nodes that are not <a>inter-element whitespace</a>, then
          create a new DOM range whose <span title="concept-range-start">start</a> is the 
          <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>current automatic annotation
          range start</var>) and whose <span title="concept-range-end">end</a> is the 
          <span title="concept-range-bp">boundary point</a> (<var>root</var>, <var>index</var>), and
          append it at the end of <var>annotations</var>.
        </li>
        <li>Let <var>current automatic annotation nodes</var> be an empty list of DOM nodes.</li>
        <li>Let <var>current automatic annotation range start</var> be null.</li>
      </ol>
    </section>
    
    <section>
      <h2>The <dfn><code>rp</code></dfn> element</h2>
      <dl class="element">
       <dt><span title="element-dfn-categories">Categories</span>:</dt>
       <dd>None.</dd>
       <dt><span title="element-dfn-contexts">Contexts in which this element can be used</span>:</dt>
       <dd>
         As a child of a <code>ruby</code> element, either immediately before or immediately after an 
         <code>rt</code> or <code>rtc</code> element.
        </dd>
       <dt><span title="element-dfn-content-model">Content model</span>:</dt>
       <dd><span>Phrasing content</span>.</dd>
       <dt><span title="element-dfn-attributes">Content attributes</span>:</dt>
       <dd><span>Global attributes</span></dd>
       <dt><span title="element-dfn-dom">DOM interface</span>:</dt><!--TOPIC:DOM APIs-->
       <dd>Uses <code>HTMLElement</code>.</dd>
      </dl><!--TOPIC:HTML-->

      <p>The <code>rp</code> element can be used to provide parentheses around a ruby text component of
      a ruby annotation, to be shown by user agents that don't support ruby annotations.</p>

      <p>An <code>rp</code> element <span class="impl">that is a child of a <code>ruby</code>
      element</span> <span>represents</span> nothing. <span class="impl">An <code>rp</code> element
      whose parent element is not a <code>ruby</code> element <span>represents</span> its
      children.</span></p>

      <div class="example">
        <p>
          The example above, in which each ideograph in the text <span
          title="" lang="ja">&#28450;&#23383;</span> is annotated with its
          phonetic reading, could be expanded to use <code>rp</code> so that in
          legacy user agents the readings are in parentheses:
        </p>

        <pre lang="ja">...
    &lt;ruby>
      &#28450;
      &lt;rb>&#23383;&lt;/rb>
      &lt;rp> (&lt;/rp>
      &lt;rt>&#12363;&#12435;&lt;/rt>
      &lt;rt>&#12376;&lt;/rt>
      &lt;rp>) &lt;/rp>
    &lt;/ruby>
...</pre>

        <p>
          In conforming user agents the rendering would be as above, but
          in user agents that do not support ruby, the rendering would
          be:
        </p>

        <pre lang="ja">... &#28450;&#23383; (&#12363;&#12435;&#12376;) ...</pre>

      </div>
      <div class="example">

        <p>
          When there are multiple annotations for a segment, <code>rp</code> elements can also be placed
          between the annotations. Here is another copy of an earlier contrived example showing some
          symbols with names given in English and French using double-sided annotations, but this time 
          with <code>rp</code> elements as well:
        </p>

        <pre>&lt;ruby>
&#x2665;&lt;rp>: &lt;/rp>&lt;rt>Heart&lt;/rt>&lt;rp>, &lt;/rp>&lt;rtc>&lt;rt lang=fr>C&oelig;ur&lt;/rt>&lt;/rtc>&lt;rp>.&lt;/rp>
&#x2618;&lt;rp>: &lt;/rp>&lt;rt>Shamrock&lt;/rt>&lt;rp>, &lt;/rp>&lt;rtc>&lt;rt lang=fr>Tr&egrave;fle&lt;/rt>&lt;/rtc>&lt;rp>.&lt;/rp>
&#x2736;&lt;rp>: &lt;/rp>&lt;rt>Star&lt;/rt>&lt;rp>, &lt;/rp>&lt;rtc>&lt;rt lang=fr>&Eacute;toile&lt;/rt>&lt;/rtc>&lt;rp>.&lt;/rp>
&lt;/ruby></pre>

        <p>This would make the example render as follows in non-ruby-capable user agents:</p>

        <pre>&#x2665;: Heart, <span lang=fr>C&oelig;ur</span>. &#x2618;: Shamrock, <span lang=fr>Tr&egrave;fle</span>. &#x2736;: Star, <span lang=fr>&Eacute;toile</span>.</pre>
      </div>
    </section>
  </body>
</html>
